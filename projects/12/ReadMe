
log(2N) = logN + 1

這用來比較二種演算法的成長級數，以前只知道 log 很好而已，

實際上，沒有什麼感覺，今天這個演講者，講完後 ，

比較 有感覺了，以N 乘幾2 ，代表同樣一個動作， 變成了2位，

而在 log 的級數世界，變成了  只要多1 個step .

也就是，一件工作 原本10天，乘2變成20天，另一個人 只要多加一天。

取log  是要把原本 linear 的世界，轉成 log 的世界來看。


第一個小作頁，先從 Math.jack 開始實作吧,

乘法， 最簡單就是做連加，但這樣的時間複雜度是 linear ,

在整個OS 中，這麼常用到的func  , 如果是用爆力法實作，那整個os，

應該 會慢到爆了 ， 要實作乘法，最簡單就 是用 連加，但不好，

另一個方法就 是用  bit 位移，來計算，但是，要轉成二進位，沒有可用的function ,

我想到，乘法的梗了，首先，這是個 16 bits 的位元，我記起每個bit 相對應的十進位數，

然後二數相減，剩下的值 大於 0 的話 ，這個bit 就 放1 ，就 這樣一個個減下去。

然後 每個bit 的值， 用陣 列存起來 。


來想一下 2's 補數，能夠讓 正數跟負數，直接相加，值還是對的，但每次都會忘了，

負數的表示式， 先拿4個bits 來看，  -8 ~ 0 ~ 7 , 4個bits ，用來表示16 個數值，

沒錯， 最左的bit 為1  ，代表這是負數，我們拿  -8 跟 7 來實驗，也就是

1000 + 0111 = 1111 ，-8 + 7 = -1 , 所以可以推敲出來， 全部都是1 的話 ，

就是 -1  , 最大的負數值，加上，前面有 1的值，

先來想正數，4個bits 的話 ， index 分別是  0 1 2 3 , 只能用 0 1 2 去做相減，

減完還是正數的話 ，這個index 的值就給 1  ，一直這樣減，減到index 0 的位置 ，

這個位置 的值是1  ，

好， 來想想負數， index 3的值是  -8  , 這是整個bit 裡面最大的負數，

用給 的值跟 -8  做相減， 等於0 最好， 但一班 都會大於0 ，這裡用 -3 來想好了，

-3 - (-8) = 5 ,  5 = 4 + 1 => 1101 = -8 + 5 = -3


由此看來，整個 2 補數的值很容易看， ( 最大負值 ) + 0 ~ n-2 的這些正數值總合 ＝ 十進位值

除了加減法，還有 and or 這二個可以用丫


